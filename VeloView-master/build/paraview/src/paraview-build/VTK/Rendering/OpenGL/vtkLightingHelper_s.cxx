/* DO NOT EDIT.
 * Generated by ../../../bin/vtkEncodeString-pv4.3
 * 
 * Define the vtkLightingHelper_s string.
 *
 * Generated from file: /home/marko/research/VeloView-master/build/paraview/src/paraview/VTK/Rendering/OpenGL/vtkLightingHelper_s.glsl
 */
#include "vtkLightingHelper_s.h"
const char *vtkLightingHelper_s =
"//=========================================================================\n"
"//\n"
"//  Program:   Visualization Toolkit\n"
"//  Module:    vtkLightingHelper_s.glsl\n"
"//\n"
"//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n"
"//  All rights reserved.\n"
"//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n"
"//\n"
"//     This software is distributed WITHOUT ANY WARRANTY; without even\n"
"//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n"
"//     PURPOSE.  See the above copyright notice for more information.\n"
"//\n"
"//=========================================================================\n"
"\n"
"#version 110\n"
"\n"
"// Filename: vtkLightingHelper_s.glsl\n"
"// Filename is useful when using gldb-gui\n"
"\n"
"// This file defines some lighting functions.\n"
"// They can be used either in a vertex or fragment shader.\n"
"\n"
"// It is intended to be used in conjunction with vtkLightsSwitches class.\n"
"\n"
"// Those functions expect uniform variables about the status of lights\n"
"// 1. In fixed-mode pipeline (glUseProgram(0)),\n"
"// 2. get the values with GLboolean lightSwitch[i]=glIsEnabled(GL_LIGHTi);\n"
"// 3. Switch to programmable pipeline (glUseProgram(prog))\n"
"// 4. Send boolean as uniform: var=glGetUniformLocation(prog,\"lightSwitch[i]\");\n"
"// 5. glUniform1i(var,lightSwitch[i]);\n"
"\n"
"// vtkLightsSwitches class can do that for you.\n"
"\n"
"\n"
"// Example in vertex shader:\n"
"// Reminder: two-sided/one-sided is controlled by GL_VERTEX_PROGRAM_TWO_SIDE\n"
"//\n"
"// vec4 eyeCoords=gl_ModelViewMatrix*gl_Vertex;\n"
"// vec4 n=gl_Normalmatrix*gl_Normal;\n"
"// n=normalize(n);\n"
"// separateSpecularColor(gl_FrontMaterial,eyeCoords,n,gl_FrontColor,gl_FrontSecondaryColor);\n"
" // If two-sided.\n"
"// separateSpecularColor(gl_BackMaterial,eyeCoords,n,gl_BackColor,gl_BackSecondaryColor);\n"
"\n"
" // Typical:\n"
"// gl_FrontColor=singleColor(gl_FrontMaterial,eyeCoords,n);\n"
"\n"
"// This is convenience method to use in shader but you better do\n"
"// this computation on the CPU and send the result as a uniform.\n"
"\n"
"// True if any enabled light is a positional one.\n"
"bool needSurfacePositionInEyeCoordinates()\n"
"{\n"
"  bool result=false;\n"
"  for (int i=0; !result && (i < gl_MaxLights); i++)\n"
"    {\n"
"    result = (gl_LightSource[i].diffuse.w != 0.0) &&\n"
"      (gl_LightSource[i].position.w != 0.0);\n"
"    }\n"
"\n"
"  return result;\n"
"}\n"
"\n"
"// Lighting computation based on a material m,\n"
"// a position on the surface expressed in eye coordinate (typically a vertex\n"
"//  position in a vertex shader, something interpolated in a fragment shader),\n"
"// a unit normal `n' to the surface in eye coordinates.\n"
"// Most of the components are in cpri (primary color), the specular\n"
"// component is in csec (secondary color).\n"
"// Useful for blending color and textures.\n"
"void separateSpecularColor(gl_MaterialParameters m,\n"
"                           vec3 surfacePosEyeCoords,\n"
"                           vec3 n,\n"
"                           out vec4 cpri,\n"
"                           out vec4 csec)\n"
"{\n"
"  cpri = m.emission + m.ambient * gl_LightModel.ambient; // ecm+acm*acs\n"
"  csec = vec4(0.0,0.0,0.0,1.0);\n"
"  vec3 wReverseRayDir = surfacePosEyeCoords;\n"
"\n"
"  // For each light,\n"
"  for (int i=0; i < gl_MaxLights; i++)\n"
"    {\n"
"    // Trick.\n"
"    bool lightEnabled = (gl_LightSource[i].diffuse.w != 0.0);\n"
"    if (!lightEnabled)\n"
"      {\n"
"      continue;\n"
"      }\n"
"\n"
"    vec3 ldir;\n"
"    vec3 h;\n"
"    float att;\n"
"    float spot;\n"
"    float shininessFactor;\n"
"\n"
"    if (gl_LightSource[i].position.w != 0.0)\n"
"      {\n"
"      // ldir=light direction\n"
"      vec3 lightPos=gl_LightSource[i].position.xyz/\n"
"        gl_LightSource[i].position.w;\n"
"      ldir = lightPos - surfacePosEyeCoords;\n"
"      float sqrDistance = dot(ldir,ldir);\n"
"      ldir = normalize(ldir);\n"
"      h = normalize(ldir + wReverseRayDir);\n"
"      att = 1.0 / (gl_LightSource[i].constantAttenuation + gl_LightSource[i].linearAttenuation *\n"
"        sqrt(sqrDistance) + gl_LightSource[i].quadraticAttenuation * sqrDistance);\n"
"      }\n"
"    else\n"
"      {\n"
"      att = 1.0;\n"
"      ldir = gl_LightSource[i].position.xyz;\n"
"      ldir = normalize(ldir);\n"
"      h = normalize(ldir + wReverseRayDir);\n"
"      }\n"
"\n"
"    if (att>0.0)\n"
"      {\n"
"      if (gl_LightSource[i].spotCutoff == 180.0)\n"
"        {\n"
"        spot = 1.0;\n"
"        }\n"
"      else\n"
"        {\n"
"        float coef=-dot(ldir,gl_LightSource[i].spotDirection);\n"
"        if (coef>=gl_LightSource[i].spotCosCutoff)\n"
"          {\n"
"          spot=pow(coef,gl_LightSource[i].spotExponent);\n"
"          }\n"
"        else\n"
"          {\n"
"          spot=0.0;\n"
"          }\n"
"        }\n"
"      if (spot>0.0)\n"
"        {\n"
"        // LIT operation...\n"
"        float nDotL=dot(n,ldir);\n"
"        float nDotH=dot(n,h);\n"
"\n"
"        // separate nDotL and nDotH for two-sided shading, otherwise we\n"
"        // get black spots.\n"
"\n"
"        if (nDotL<0.0) // two-sided shading\n"
"          {\n"
"          nDotL=-nDotL;\n"
"          }\n"
"\n"
"        if (nDotH<0.0) // two-sided shading\n"
"          {\n"
"          nDotH=-nDotH;\n"
"          }\n"
"        // ambient term for this light\n"
"        vec4 cpril=m.ambient*gl_LightSource[i].ambient;// acm*adi\n"
"\n"
"        // diffuse term for this light\n"
"        if (nDotL>0.0)\n"
"          {\n"
"          cpril+=m.diffuse*gl_LightSource[i].diffuse*nDotL; // dcm*dcli\n"
"          }\n"
"\n"
"        // specular term for this light\n"
"        shininessFactor=pow(nDotH,m.shininess); // srm\n"
"\n"
"        cpri+=att*spot*cpril;\n"
"\n"
"        // scm*scli\n"
"        csec+=att*spot*\n"
"          m.specular*gl_LightSource[i].specular*shininessFactor;\n"
"\n"
"        }\n"
"      }\n"
"    }\n"
"}\n"
"\n"
"\n"
"// Lighting computation based on a material m,\n"
"// a position on the surface expressed in eye coordinate (typically a vertex\n"
"//  position in a vertex shader, something interpolated in a fragment shader),\n"
"// a unit normal to the surface in eye coordinates.\n"
"// The result includes the specular component.\n"
"vec4 singleColor(gl_MaterialParameters m,\n"
"                 vec3 surfacePosEyeCoords,\n"
"                 vec3 n)\n"
"{\n"
" vec4 cpri;\n"
" vec4 csec;\n"
" separateSpecularColor(m,surfacePosEyeCoords,n,cpri,csec);\n"
" return cpri+csec;\n"
"}\n"
"\n";

